# Command Line Parser

## Summary

For command line parsing the POSIX `getopt` and `getopt_long` are available.
Those functions have several downsides:

 * Are not available on all platforms (Windows).
 * Are error prone to use. The user has to consider all conversion edge cases
    and verify the syntax.
 * Are hard to use and the API is hard to read.
 * One has to write a lot of code to use them, even for minimal problems.
 * How the help is shown, how the help is formatted and certain syntax decision
    can vary from binary to binary in iceoryx. A unified appearance and usage
    across all applications would increase the user experience.

Since we would like to offer command line support on all platforms we either
have to rewrite `getopt` and `getopt_long` from scratch or write a modern C++
alternative.

## Terminology

| Name              | Description                                              |
| :---------------- | :------------------------------------------------------- |
| switch            | When provided as argument the switch is activated, see `-h` and `--help`. A boolean signals to the user whether the switch was provided (activated) or not. |
| optional value    | A value which can be provided via command line but is not required. Every optional value requires a default value. |
| required value    | A value which has to be provided via command line. Does not require a default value. |
| argc & argv       | Taken from `int main(int argc, char* argv[])`. Provides access to the command line arguments. |
| short option      | Consists of a minus followed by a non minus symbol, see `-h` or `-a 123`. |
| long option       | Has a double minus prefix followed by a string, see `--help` or `--set-thing 123` |

## Design

### Considerations

The solution shall be:

 * easy to use by the developer
 * provide a unified appearance and syntax in all applications with command line arguments
    * the help must be generated by the parser
    * the help shall contain the type if an argument requires a value
    * the syntax is defined by the parser not the developer as much as possible
 * shall be type safe when command line arguments are converted to types like `int` or `float`
    * underflow, overflow shall be handled
    * a detailed error explanation shall be presented to the user when cast fails

### Solution

#### Class Diagram

```
+----------------------------------------------+  Task:
| CommandLineParser                            |     * extract user defined values as string from command line
|                                              |     * "parse" creates a CommandLineOptions object through
|  - CommandLineParser & addSwitch(...)        |         which those values can be accessed
|  - CommandLineParser & addOptionalValue(...) |     * it generates the help output based on the provided user
|  - CommandLineParser & addRequiredValue(...) |         arguments and prints it on syntax failure or user
|                                              |         request (-h or --help)
|  - CommandLineOptions parse(argc, argv, ...) |
+----------------------------------------------+
                      |
                      | creates CommandLineOptions
                     \ /
+----------------------------------------------+  Task:
| CommandLineOptions                           |     * provides a type safe access to the user defined command
|                                              |         line values with `get`, `has` or `binaryName`
|  +----------------------------+              |
|  | Result [enum class]        |              |
|  |  # UNABLE_TO_CONVERT_VALUE |              |
|  |  # NO_SUCH_VALUE           |              |
|  +----------------------------+              |
|                                              |
|  - template<typename T>                      |
|    cxx::expected<T, Result> get(optionName)  |
|  - bool has(switchName)                      |
|  - binaryName_t binaryName()                 |
|                                              |
+----------------------------------------------+
```

#### Macro Based Code Generator

The macros `COMMAND_LINE`, `SWITCH`, `OPTIONAL_VALUE` and `REQUIRED_VALUE`
provide building blocks so that the user can generate a struct. The members of that
struct are defined via the macros and set in the constructor of that struct which
will use `CommandLineParser` and `CommandLineOptions` to parse and extract the
values safely.

The struct constructor can be called with `argc` and `argv` as arguments from 
`int main(int argc, char* argv[])`.

### Code example

```cpp
struct CommandLine
{
    COMMAND_LINE(CommandLine, "My program description");

    OPTIONAL_VALUE(string<100>, stringValue, {"default Value"}, 's', "string-value", "some description");
    REQUIRED_VALUE(string<100>, anotherString, 'a', "another-string", "some description");
    SWITCH(doStuff, 'd', "do-stuff", "do some stuff - some description");
    OPTIONAL_VALUE(uint64_t, version, 0, 'v', "version", "some description");
};

// This struct parses all command line arguments and stores them. In
// the example above the struct provides access to
//   .stringValue()
//   .anotherString()
//   .doStuff()
//   .version()
// Via the command line parameters
//   -s or --string-value
//   -a or --another-string
//   -d or --do-stuff
//   -v or --version

int main(int argc, char* argv[]) {
  CommandLine cmd(argc, argv);
  std::cout << cmd.stringValue() << " " << cmd.anotherString() << std::endl;
}
```

## Open issues

Our `iox` tool should be structured similar like the `ros2` tool. This
means `iox COMMAND ARGUMENTS_OF_THE_COMMAND`. The current implementation allows us
only to parse the `ARGUMENTS_OF_THE_COMMAND` but not handle the `COMMAND` in an easy manner.

A follow up pull request will address this issue.

The structure will look like the following (taken from proof of concept):
```cpp
struct Command {
    cxx::string command;
    cxx::function<void(int, char**)> call;
};

// this generates a help with an overview of all available commands which can
// be printed with --help or when a syntax error occurs
bool parseCommand(argc, argv, vector<Command> availableCommands);

void userDefinedCommand1(argc, argv) {
    // here we use the already implemented CommandLineStruct to parse the
    // arguments of the command
    // The CommandLineStruct generates the help for the command line arguments
    // of that specific command
}

void userDefinedCommand2(argc, argv) {
}

int main(int argc, char* argv[]) {
    parseCommand(argc, argv, {{"command1", userDefinedCommand1},
                              {"anotherCommand", userDefinedCommand2}});
}
```

The idea is to handle every command independently from every other command and
do not define everything in one big command line parser object which would
violate the separation of concerns.
