# Command Line Parser

## Summary

For command line parsing the POSIX `getopt` and `getopt_long` are available.
Those functions have several downsides:

 * Are not available on all platforms (Windows).
 * Are error prone to use. The user has to consider all conversion edge cases
    and verify the syntax.
 * Are hard to use and the API is hard to read.
 * One has to write a lot of code to use them, even for minimal problems.
 * How the help is shown, how the help is formatted and certain syntax decision
    can vary from binary to binary in iceoryx. A unified appearance and usage
    across all applications would increase the user experience.

Since we would like to offer command line support on all platforms we either
have to rewrite `getopt` and `getopt_long` from scratch or write a modern C++
alternative.

## Terminology

The terminology is close to the terminology used in the POSIX.1-2017 standard.
For more details see
[Utility Conventions](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html).

Assume we have a iceoryx tool with command line arguments like:
```
iox_tool -a --bla -c 123 --dr_dotter blubb
```

| Name              | Description                                              |
| :---------------- | :------------------------------------------------------- |
| options           | Arguments which start with minus `-` or `--`, like `-a` or `--bla`. |
| short option      | Argument which starts with a single minus followed by a non-minus symbol, like `-a` or `-c` |
| long option       | Argument which starts with two minus followed by at least another non-minus symbol, like `--bla` or `--dr_dotter` |
| option name       | The symbols after the leading minus of an option, for instance `a` or `dr_dotter`. |
| option argument   | Argument which is separated by a space from an option, like `123` or `blubb`. |
| argc & argv       | Taken from `int main(int argc, char* argv[])`. Provides access to the command line arguments. |

### Option Types

| Name              | Description                                              |
| :---------------- | :------------------------------------------------------- |
| switch            | When provided as argument the switch is activated, see `-h` and `--help`. A boolean signals to the user whether the switch was provided (activated) or not. |
| optional          | A value which can be provided via command line but is not required. Every optional option requires a default value. |
| required          | A value which has to be provided via command line. Does not require a default value. |

Every option has an option argument but since the switch is boolean in nature
the argument is implicitly provided when stating the option.

## Design

### Considerations

The solution shall be:

 * easy to use by the developer
 * provide a unified appearance and syntax in all applications with command line arguments
    * the help must be generated by the parser
    * the help shall contain the type if an argument requires a value
    * the syntax is defined by the parser not the developer as much as possible
 * shall be type safe when command line arguments are converted to types like `int` or `float`
    * underflow, overflow shall be handled
    * a detailed error explanation shall be presented to the user when cast fails

### Solution

#### Class Diagram

```
+----------------------------------------------+  Task:
| CommandLineParser                            |     * extract user defined values as string from command line
|                                              |     * "parse" creates a CommandLineOptions object through
|  - CommandLineParser & addSwitch(...)        |         which those values can be accessed
|  - CommandLineParser & addOptional(...)      |     * it generates the help output based on the provided user
|  - CommandLineParser & addRequired(...)      |         arguments and prints it on syntax failure or user
|                                              |         request (-h or --help)
|  - CommandLineOptions parse(argc, argv, ...) |
+----------------------------------------------+
                      |
                      | creates CommandLineOptions
                     \ /
+----------------------------------------------+  Task:
| CommandLineOptions                           |     * provides a type safe access to the user defined command
|                                              |         line values with `get`, `has` or `binaryName`
|  +----------------------------+              |
|  | Error [enum class]        |              |
|  |  # UNABLE_TO_CONVERT_VALUE |              |
|  |  # NO_SUCH_VALUE           |              |
|  +----------------------------+              |
|                                              |
|  - template<typename T>                      |
|    cxx::expected<T, Error> get(optionName)  |
|  - bool has(switchName)                      |
|  - binaryName_t binaryName()                 |
|                                              |
+----------------------------------------------+
```

#### Sequence Diagram

Lets assume we would like to add a switch, an optional and a required option, parse
them and print them on the console.

```
  User
   |  CommandLineParser()    CommandLineParser
   | ------------------------------> |
   |                                 |
   |    addSwitch()                  |
   | ------------------------------> |
   |                                 |
   |    addOptional()                |
   | ------------------------------> |
   |                                 |
   |    addRequired()                |
   | ------------------------------> |
   |                                 |
   |    parse()                      |
   | ------------------------------> |
   |    CommandLineOptions                    CommandLineOptions
   |                                                   |
   |                has(switchName)                    |
   | ------------------------------------------------> |
   |                bool                               |
   |                                                   |
   |                get<TypeName>(optionalOptionName)  |
   | ------------------------------------------------> |
   |                TypeName                           |
   |                                                   |
   |                get<TypeName>(requiredOptionName) |
   | ------------------------------------------------> |
   |                TypeName                           |
```

#### Macro Based Code Generator

The macros `IOX_CLI_DEFINITION`, `IOX_CLI_SWITCH`, `IOX_CLI_OPTIONAL` and `IOX_CLI_MANDATORY`
provide building blocks so that the user can generate a struct. The members of that
struct are defined via the macros and set in the constructor of that struct which
will use `CommandLineParser` and `CommandLineOptions` to parse and extract the
values safely.

The struct constructor can be called with `argc` and `argv` as arguments from 
`int main(int argc, char* argv[])`.

### Code example

```cpp
struct CommandLine
{
    IOX_CLI_DEFINITION(CommandLine, "My program description");

    IOX_CLI_OPTIONAL(string<100>, stringValue, {"default Value"}, 's', "string-value", "some description");
    IOX_CLI_REQUIRED(string<100>, anotherString, 'a', "another-string", "some description");
    IOX_CLI_SWITCH(doStuff, 'd', "do-stuff", "do some stuff - some description");
    IOX_CLI_OPTIONAL(uint64_t, version, 0, 'v', "version", "some description");
};

// This struct parses all command line arguments and stores them. In
// the example above the struct provides access to
//   .stringValue()
//   .anotherString()
//   .doStuff()
//   .version()
// Via the command line parameters
//   -s or --string-value
//   -a or --another-string
//   -d or --do-stuff
//   -v or --version

int main(int argc, char* argv[]) {
  CommandLine cmd(argc, argv);
  std::cout << cmd.stringValue() << " " << cmd.anotherString() << std::endl;
}
```

## Open issues

Our `iox` tool should be structured similar like the `ros2` tool. This
means `iox COMMAND ARGUMENTS_OF_THE_COMMAND`. The current implementation allows us
only to parse the `ARGUMENTS_OF_THE_COMMAND` but not handle the `COMMAND` in an easy manner.

A follow up pull request will address this issue.

The structure will look like the following (taken from proof of concept):
```cpp
struct Command {
    cxx::string command;
    cxx::function<void(int, char**)> call;
};

// this generates a help with an overview of all available commands which can
// be printed with --help or when a syntax error occurs
bool parseCommand(argc, argv, const vector<Command> & availableCommands);

void userDefinedCommand1(argc, argv) {
    // here we use the already implemented CommandLineStruct to parse the
    // arguments of the command
    // The CommandLineStruct generates the help for the command line arguments
    // of that specific command
}

void userDefinedCommand2(argc, argv) {
}

int main(int argc, char* argv[]) {
    parseCommand(argc, argv, {{"command1", userDefinedCommand1},
                              {"anotherCommand", userDefinedCommand2}});
}
```

The idea is to handle every command independently from every other command and
do not define everything in one big command line parser object which would
violate the separation of concerns.
